---
import { readFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { iconMap, getIconComponentName } from "../data/icons";

interface Props {
  name: string;
  variant?: "outline" | "solid" | "mini";
  size?: string | number;
  class?: string;
  id?: string;
}

const {
  name,
  variant = "outline",
  size = 24,
  class: className = "",
  id,
} = Astro.props;

// Кэш для загруженных иконок (в памяти, для SSR)
const iconCache = new Map<string, { content: string; viewBox: string }>();

const heroiconName = iconMap[name] || name;
const iconComponentName = getIconComponentName(heroiconName);

let iconContent = "";
let viewBox = "0 0 24 24";

// Создаем уникальный ключ для кэша
const cacheKey = `${iconComponentName}-${variant}`;

// Проверяем кэш
const cached = iconCache.get(cacheKey);
if (cached) {
  iconContent = cached.content;
  viewBox = cached.viewBox;
} else {
  try {
    // Получаем корень проекта - пробуем разные способы
    let projectRoot: string;
    try {
      // В Astro process.cwd() должен работать
      projectRoot = process.cwd();
    } catch {
      // Fallback: используем import.meta.url
      const __filename = fileURLToPath(import.meta.url);
      const __dirname = dirname(__filename);
      projectRoot = join(__dirname, "../../../");
    }

    // Heroicons React структура: node_modules/@heroicons/react/24/outline/IconNameIcon.js
    const sizeDir = variant === "mini" ? "20" : "24";
    const variantDir = variant === "mini" ? "solid" : variant;
    const iconPath = join(
      projectRoot,
      "node_modules",
      "@heroicons",
      "react",
      sizeDir,
      variantDir,
      `${iconComponentName}.js`,
    );

    // Читаем JS файл и извлекаем SVG из JSX
    const jsContent = readFileSync(iconPath, "utf-8");

  // Ищем viewBox в svg элементе
  const viewBoxMatch = jsContent.match(/viewBox:\s*"([^"]+)"/);
  if (viewBoxMatch) {
    viewBox = viewBoxMatch[1];
  }

  // Извлекаем все path элементы из JSX
  // Ищем все вхождения React.createElement("path", {...})
  const pathMatches = [
    ...jsContent.matchAll(/React\.createElement\("path",\s*\{([\s\S]*?)\}\)/g),
  ];

  for (const match of pathMatches) {
    const pathProps = match[1];
    const pathAttrs: string[] = [];

    // Извлекаем d атрибут - может быть на одной или нескольких строках
    const dMatch = pathProps.match(/d:\s*"([^"]+)"/);
    if (dMatch) {
      pathAttrs.push(`d="${dMatch[1]}"`);
    }

    // Извлекаем strokeLinecap
    const strokeLinecapMatch = pathProps.match(/strokeLinecap:\s*"([^"]+)"/);
    if (strokeLinecapMatch) {
      pathAttrs.push(`stroke-linecap="${strokeLinecapMatch[1]}"`);
    }

    // Извлекаем strokeLinejoin
    const strokeLinejoinMatch = pathProps.match(/strokeLinejoin:\s*"([^"]+)"/);
    if (strokeLinejoinMatch) {
      pathAttrs.push(`stroke-linejoin="${strokeLinejoinMatch[1]}"`);
    }

    if (pathAttrs.length > 0) {
      iconContent += `<path ${pathAttrs.join(" ")} />`;
    }
  }

    // Сохраняем в кэш
    iconCache.set(cacheKey, { content: iconContent, viewBox });
  } catch (e: any) {
    if (import.meta.env.DEV) {
      const errorMsg = e?.message || String(e);
      const errorPath = e?.path || "unknown";
      console.warn(`Icon not found: ${heroiconName} (${variant})`, {
        error: errorMsg,
        path: errorPath,
        componentName: iconComponentName,
      });
    }
  }
}

const sizeValue = typeof size === "number" ? `${size}px` : size;
---

{
  iconContent && (
    <svg
      width={sizeValue}
      height={sizeValue}
      viewBox={viewBox}
      fill={variant === "solid" ? "currentColor" : "none"}
      stroke={variant === "solid" ? "none" : "currentColor"}
      stroke-width={variant === "solid" ? "0" : "1.5"}
      stroke-linecap="round"
      stroke-linejoin="round"
      class={className}
      id={id}
      set:html={iconContent}
    />
  )
}
